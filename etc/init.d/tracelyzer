#!/bin/sh
#
# Example init.d script with LSB support.
#
# Please read this init.d carefully and modify the sections to
# adjust it to the program you want to run.
#
# Copyright (c) 2007 Javier Fernandez-Sanguino <jfs@debian.org>
#
# This is free software; you may redistribute it and/or modify
# it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2,
# or (at your option) any later version.
#
# This is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License with
# the Debian operating system, in /usr/share/common-licenses/GPL;  if
# not, write to the Free Software Foundation, Inc., 59 Temple Place,
# Suite 330, Boston, MA 02111-1307 USA
#
### BEGIN INIT INFO
# Provides:          tracelyzer
# Required-Start:    $network $local_fs
# Required-Stop:
# Should-Start:      $named
# Should-Stop:
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: <Enter a short description of the sortware>
# Description:       <Enter a long description of the software>
#                    <...>
#                    <...>
### END INIT INFO

PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

DAEMON=/usr/bin/tracelyzer  # Introduce the server's location here
DAEMON2=/usr/bin/tracelyzer-conn
NAME=tracelyzer             # Introduce the short server's name here
NAME2=tracelyzer-conn
DESC=tracelyzer             # Introduce a short description here
LOGDIR=/var/log/tracelyzer  # Log directory to use

PIDFILE=/var/run/tracelyzer/$NAME.pid
PIDFILE2=/var/run/tracelyzer/$NAME2.pid

test -x $DAEMON || exit 0
test -x $DAEMON2 || exit 0

. /etc/init.d/functions

DIETIME=5               # Time to wait for the server to die, in seconds
                        # If this value is set too low you might not
                        # let some servers to die gracefully and
                        # 'restart' will not work

#STARTTIME=2             # Time to wait for the server to start, in seconds
                        # If this value is set each time the server is
                        # started (on start or restart) the script will
                        # stall to try to determine if it is running
                        # If it is not set and the server takes time
                        # to setup a pid file the log message might
                        # be a false positive (says it did not start
                        # when it actually did)

LOGFILE=$LOGDIR/$NAME.log  # Server logfile
LOGFILE2=$LOGDIR/$NAME2.log
DAEMONUSER=appneta      # Users to run the daemons as. If this value
                        # is set start-stop-daemon will chuid the server

CONF_TRACELYZER=/etc/tracelyzer/tracelyzer.conf
CONF_CLIENT_PRIV=/etc/tracelyzer/auth_client
CONF_SERVER_PUB=/etc/tracelyzer/auth_server.pub

COLLECTOR_HOST=incoming.tracelytics.com
COLLECTOR_PORT=2222

# Include collector config file (downloaded by appneta-config)
LISTEN_HOST=127.0.0.1
LISTEN_PORT=7831

AUTOSSH_DEBUG=0

if [ -f /etc/tracelyzer/collector.conf ]; then
    . /etc/tracelyzer/collector.conf
fi

# Include defaults if available
if [ -f /etc/sysconfig/tracelyzer ] ; then
        . /etc/sysconfig/tracelyzer
fi

DAEMON_OPTS="-c $CONF_TRACELYZER -d -P $PIDFILE -l $LOGFILE  -L $LISTEN_HOST -O $LISTEN_PORT"          # Additional options given to the server
DAEMON2_OPTS="-M 0 -f -NnC -i $CONF_CLIENT_PRIV -L 7831:127.0.0.1:1463"
case "$(ssh -V 2>&1 1>/dev/null)" in
    # ExitOnForwardFailure option added in OpenSSH 4.4
    OpenSSH_4.[4-9]*|OpenSSH_[5-9]*)
        DAEMON2_OPTS="$DAEMON2_OPTS -o ExitOnForwardFailure=yes" ;;
    *) ;;
esac
DAEMON2_OPTS="$DAEMON2_OPTS"\
" -o UserKnownHostsFile=$CONF_SERVER_PUB"\
" -o StrictHostKeyChecking=yes"\
" -o CheckHostIP=no"\
" -o ServerAliveInterval=30"\
" -o ServerAliveCountMax=2"

# SOCKS proxy variables configured?
if [ -n "$PROXY_ADDRESS" ]; then
  if [ -z "$NC_COMMAND" ]; then
    NC_COMMAND=`which nc`
    if [ "$?" -ne "0" ]; then
	echo "ERROR: SOCKS proxy support requires netcat (nc)."
	echo "Please install netcat or contact us at traceviewsupport@appneta.com for assistance."
        exit 1
    fi
  fi
  if [ -n "$PROXY_PROTOCOL" ]; then
    PROXY_PROTO_OPT="-X $PROXY_PROTOCOL"
  fi
  DAEMON2_OPTS="$DAEMON2_OPTS -o ProxyCommand=\"$NC_COMMAND $PROXY_PROTO_OPT -x $PROXY_ADDRESS %h %p\""
fi

DAEMON2_OPTS="$DAEMON2_OPTS -p $COLLECTOR_PORT customer@$COLLECTOR_HOST"

# Check that the user exists (if we set a user)
# Does the user exist?
if [ -n "$DAEMONUSER" ] ; then
    if getent passwd | grep -q "^$DAEMONUSER:"; then
        # Obtain the uid and gid
        DAEMONUID=`getent passwd |grep "^$DAEMONUSER:" | awk -F : '{print $3}'`
        DAEMONGID=`getent passwd |grep "^$DAEMONUSER:" | awk -F : '{print $4}'`
    else
        echo -n "The user $DAEMONUSER, required to run $NAME does not exist."
        exit 0
    fi
fi


set -e

running() {
  [ -f $PIDFILE ] && [ -d "/proc/`cat $PIDFILE`" ]
}

running2() {
  [ -f $PIDFILE2 ] && [ -d "/proc/`cat $PIDFILE2`" ]
}

start_server() {
        if [ ! -s $CONF_TRACELYZER ] ||
           [ ! -s $CONF_CLIENT_PRIV ] || 
           [ ! -s $CONF_SERVER_PUB ]; then
           echo -n "Error: required file does not exist.  Perhaps you forgot to run /usr/sbin/appneta-config?"
           return 1
        else

		daemon --pidfile $PIDFILE2 \
			    --user $DAEMONUSER \
			    AUTOSSH_LOGFILE=$LOGFILE2 \
                            AUTOSSH_PIDFILE=$PIDFILE2 \
                            AUTOSSH_GATETIME=0 \
                            AUTOSSH_DEBUG=$AUTOSSH_DEBUG \
                            "$DAEMON2 $DAEMON2_OPTS"
		errcode=$?
		if [ $errcode != 0 ]; then
		    return $errcode
		fi
		[ -f $PIDFILE2 ] && echo >> $PIDFILE2
		sleep 2
		echo
		daemon --pidfile $PIDFILE \
			    --user $DAEMONUSER \
			    $DAEMON $DAEMON_OPTS
		errcode=$?
		[ -f $PIDFILE ] && echo >> $PIDFILE
		echo
		return $errcode

        fi
}

stop_server() {
	set +e
        killproc -p $PIDFILE -d 100 $DAEMON
	echo
        killproc -p $PIDFILE2 -d 100 $DAEMON2
	set -e
        return 0
}

case "$1" in
  start)
        echo -n "Starting ${DESC}: ${NAME}..."
        # Check if it's running first
        if running || running2;  then
            echo "apparently already running"
            exit 0
        fi
        if start_server ; then
            # NOTE: Some servers might die some time after they start,
            # this code will detect this issue if STARTTIME is set
            # to a reasonable value
            [ -n "$STARTTIME" ] && sleep $STARTTIME # Wait some time 
            if running && running2;  then
                # It's ok, the server started and is running
                true
            else
                # It is not running after we did start
                echo "Failed to start!"
            fi
        else
            echo "Failed to start!"
        fi
        ;;
  stop)
        echo -n "Stopping ${DESC}: $NAME..."
        if running || running2; then
            # Only stop the server if we see it running
            stop_server
            if running || running2; then
                echo "failed to stop"
            else
                echo "stopped"
            fi
            echo
        else
            # If it's not running don't do anything
            echo "apparently not running"
        fi
        ;;
  restart|force-reload)
        echo -n "Restarting ${DESC}: ${NAME}..."
        errcode=0
        stop_server || errcode=$?
        # Wait some sensible amount, some server need this
        [ -n "$DIETIME" ] && sleep $DIETIME
        start_server || errcode=$?
        [ -n "$STARTTIME" ] && sleep $STARTTIME
        ( running && running2 ) || errcode=$?
        ;;
  status)

        echo -n "Checking status of ${DESC}: ${NAME}..."
        if running || running2;  then
            echo "running"
        else
            echo "apparently not running"
            exit 1
        fi
        ;;
  *)
        N=/etc/init.d/$NAME
        echo "Usage: $N {start|stop|restart|force-reload|status}" >&2
        exit 1
        ;;
esac

exit 0
